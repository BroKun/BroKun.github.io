<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用Travis CI进行持续集成]]></title>
    <url>%2Fstart-using-Travis-CI%2F</url>
    <content type="text"><![CDATA[Travis CI是当前最受欢迎的CI套件，Saas模式的服务独树一帜，流畅的使用方案让人欲罢不能。作为一个Saas模式的CI服务提供者，Travis CI为你的每次构建提供一个独立的构建环境，支持多种语言，预置了多种环境配置模式，内置了多种发布模式。本文以Hexo博客构建并发布到github pages,以及Node工程构建并发布到私有服务器为例，介绍Travis的使用方式，帮助大家为自己的项目增加一枚构建徽记。 在Travis CI上注册并关联项目对于github上的开源项目，访问Travis CI,点击右上角使用github帐号登录。 登录以后在右上角的头像下，选择Accounts，会看到如下界面。 travis已经给了你很详细的使用指导： 1.把开关打开 2.添加配置文件 3.提交代码触发。 好了，全文完，谢谢大家！ 大家在这里把开关打开就算完成了。 Hexo博客构建和部署github pages的配置Hexo虽然提供了deploy到github的支持，但是对于更换机器等情况而言，依赖越多用起来越复杂，想随时随地往仓库里push一个md文件，就完成发布的话，就要考虑自动构建的方式了。 使用travis来完成这项工作有两个选择: 使用travis在自己的deploy选项，travis在近期加入了pages发布支持，只要配置几个主要信息，travis就可以完成发布动作。这个模式现在还是实验状态的，但是亲测可用。 使用构建环境，手动把文件提交的github pages仓库。 获取github token两种方式都需要使用github access token。所以我们先获取它。 登录到github→在右上角头像的下拉选项中进入Settings→找到Personal access tokens选项→点击右上角Generate new token→填入描述信息，选好权限→mission complete! 生成的token信息请妥善保管。 travis环境设置登录到travis，回到刚才repo列表页面，需要构建的项目开关旁边有一个设置按钮，点击进入设置。 在General中把构建的触发条件选好。 在Environment Variables中添加github token到环境变量 使用travis的deploy在项目中添加.travis.yml文件，内容如下:1234567891011121314151617181920language: node_jsnode_js: stableinstall:- npm installscript:- hexo gdeploy: provider: pages local_dir: public/ #用于deploy的文件夹 repo: BroKun/BroKun.github.io #Repo slug target_branch: master #分支 email: brokun0128@gmail.com #提交动作的使用的email name: BroKun #提交动作使用的帐号 skip_cleanup: true github_token: $&#123;github_token&#125; # Set in travis-ci.org dashboard on: branch: masterbranches: only: - master depoly的详细说明参见官方文档 使用手动提交的方式在项目中添加.travis.yml文件，内容如下:1234567891011121314151617181920language: node_jsnode_js: stableinstall:- npm installscript:- hexo gafter_script:- cd ./public- git init- git config user.name &quot;BroKun&quot;- git config user.email &quot;brokun0128@gmail.com&quot;- git add .- git commit -m &quot;Update docs&quot;- git push --force --quiet &quot;https://$&#123;github_token&#125;@$&#123;github_ref&#125;&quot; master:masterbranches: only: - masterenv: global: - github_ref: github.com/BroKun/BroKun.github.io.git 构建Node工程并发布到私有服务器如果希望把工程发布到自己的服务器，需要需要做的会多一点，首先要明确如何去做这件事。我的选择是构建过程和测试在travis的环境中运行，通过ssh把源码发送到远程服务器，在远程执行部署脚本。 配置远程ssh登录由于travis不支持交互式指令，所以采用ssh免密远程登陆的方式来访问远程服务器。 生成密钥对1$ ssh-keygen -t rsa 这里注意，生成私钥的时候，密码设置为空。 将公钥放在远程服务器上并设置受信12$ cat id_dsa.pub &gt;&gt; ~/.ssh/authorized_keys $ chmod 600 ~/.ssh/authorized_keys 在需要部署的项目中添加私钥并加密在项目的git托管目录中，添加.travis文件夹，将刚刚生成的私钥放入文件夹中。熟悉密钥登录方式的应该知道，我们正常是在自己的机器上保存私钥，把公钥给自己管理的服务器，这里我们是希望travis的环境替代我们自己的机器。但是私钥放置在项目中意味着暴露在了网络空间，是很不安全的，所以我们使用The Travis Client加密私钥。 安装Travis Client:1$ gem install travis PS:Travis Client是基于Ruby的，需要安装Ruby环境支持，我的机器为此增加了ruby rubygems ruby-devel等包，如果出现ruby版本问题，建议使用RVM。 登录到Travis1$ travis login 填入自己的travis帐号或github帐号信息 加密私钥1$ travis encrypt-file id_rsa --add –add参数会在git仓库内的.travis.yml中增加123before_install:- openssl aes-256-cbc -K $encrypted_cf2f27b2e746_key -iv $encrypted_cf2f27b2e746_iv -in id_rsa.enc -out id_rsa -d 在travis网站上的项目配置里，也可以看到增加了两个环境变量 travis把解密需要的信息保存在了自己的服务器上，我们就不用担心私钥信息丢失了，这时候把项目仓库.travis文件夹里的原始私钥删除，只保留id_rsa.enc就可以了。 在.travis.yml中编写构建和发布过程一个完整的例子如下:1234567891011121314151617181920212223sudo: falselanguage: node_jsnode_js:- &apos;7.10.1&apos;before_install:- openssl aes-256-cbc -K $encrypted_cf2f27b2e746_key -iv $encrypted_cf2f27b2e746_iv -in .travis/id_rsa.enc -out ~/.ssh/id_rsa -d- chmod 600 ~/.ssh/id_rsa- echo -e &quot;Host 101.200.36.181\n\tStrictHostKeyChecking no\n&quot; &gt;&gt; ~/.ssh/config- tar -czf relationship-server.tar.gz *install:- npm i npminstall &amp;&amp; npminstallscript:- npm run ciafter_script:- npminstall codecov &amp;&amp; codecov- npm i coveralls- cat ./coverage/lcov.info | node ./node_modules/coveralls/bin/coveralls- scp relationship-server.tar.gz brokun@101.200.36.181:~/- ssh brokun@101.200.36.181 &apos;rm -rf relationship-server&apos;- ssh brokun@101.200.36.181 &apos;mkdir -p relationship-server &amp;&amp; tar -xzvf relationship-server.tar.gz -C relationship-server&apos;- ssh brokun@101.200.36.181 &apos;. ./relationship-server.sh&apos; 这里的Node程序使用了Egg框架，在travis上执行lint与单元测试。结束之后使用coveralls发布了测试结果。然后发布程序，在远程服务器上我预先放置了部署脚本，来完成程序重启相关的工作。需要注意的有: Travis Client自动生成的解密脚本不能给出正确的加解密文件路径，需要手动调整。 私钥的文件访问权限一定要修改，脚本里还在.ssh文件夹增加了配置，关闭了对指定服务器的严格检查，否则会出现需要用户确认的步骤，导致脚本无法执行。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>CI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用GitLab CI进行持续集成]]></title>
    <url>%2Fstart-using-GitLab-CI%2F</url>
    <content type="text"><![CDATA[从GitLab8.0开始，就内置了GitLab CI，不管围绕着gitlab建立了怎样的workflow，CI都是不可缺少的。如果你的团队使用GitLab，同时又希望研发人员自己承担DevOps的角色，那GitLab CI将是你很好的选择。 特点 GitLab CI的构建流程依托于每台服务器上的GitLab Runner，Runner需要主动注册到Gitlab CI，免去了复杂认证设置，Runner直接在服务器上运行，对本地的操作也会更方便。 PipeLine依托在项目中配置的.gitlab-ci.yml文件，构建过程管理与研发流程贴得更近。 说明GitLab Runner构建过程的执行者，使用Go语言编写，只要能跑Go的地方就能跑。Runner分为Specific Runner与Share Runner。Shared Runner只有系统管理元可以创建，为多个项目服务。Specific Runner有工程访问权限的人都可以创建，大多数情况下，Specific Runner足够使用。 使用步骤这里以我需要配置的一个工程为例。 服务器操作系统：CentOS 7 GitLab：8.17.x 工程语言: Node.js 安装 GitLab Runner安装GitLab Runner前，首先要搞清楚自己的GitLab版本，根据官方文档给出的对应表找到自己可用的Runner版本。我这里选择使用v1.11.x 1root@host:# yum install gitlab-ci-multi-runner-1.11.2-1 GitLab Runner会在服务器上创建gitlab-runner用户，该用户的目录会生成builds文件夹，里面为每个runner建立一个文件夹，文件夹内部放置由该runner管理的信息。 其他参考 官方说明 注册 GitLab Runner我这里选择注册一个Specific Runner，需要Url和Token，这两个信息可以从GitLab的项目设置里拿到。位置在设置-&gt;runners 1root@host:# gitlab-runner register 然后根据提示依次输入URL、Token等信息其中tags信息，Whether to run untagged builds与runner执行的触发有关。executor 可以选定命令执行器，为了方便，我选择了shell 注册成功以后，可以看到如下字样：1Runner registered successfully. Feel free to start it, but if it&apos;s running already the config should be automatically reloaded! 同时会在 /etc/gitlab-runner/config.toml 生成一份配置文件，可以再次修改部分配置信息，runner会自动重启。在gitlab的runner配置项中，此时也可以看到该runner的，也可以在这里修改runner描述信息和tags等。 一个注册好的runner在其他的代码仓库也是可以看到的，可以选择在多个项目中启用。 配置.gitlab-ci.yml配置好runner以后，在项目中添加.gitlab-ci.yml文件以触发runner的执行。 概念 GitLab的CI构建过程分为Pipeline、stage、job三个层次。Pipeline是指的一个可执行的构建过程。stage是Pipeline的执行阶段。job是一个具体的执行单元，job里包含的信息最多，需要指明自己所属的stage，需要执行的命令，在什么情况下执行，在哪里执行等。 示例配置文件先给出配置文件: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748stages: - install - test - deploycache: key: $&#123;CI_BUILD_REF_NAME&#125; paths: - node_modules/# 安装依赖install: stage: install only: - dev script: - npm install# 运行测试用例test: stage: test only: - dev script: - npm run test allow_failure: true# 开发环境部署到pm2deploy_dev: stage: deploy only: - dev tags: - dev script: - pm2 delete dev || true - pm2 start config/pm2-dev.json --name dev# 测试环境部署到pm2deploy_test: stage: deploy only: - dev tags: - test script: - pm2 delete test || true - pm2 start config/pm2-test.json --name test 这份配置文件描述了一个由install、test、deploy三个stage组成的Pipeline，全部由dev分支的更新触发，install和test两个job是公共的，deploy_dev、deploy_test分别在开发和测试两个环境的runner上执行部署。 执行方式和注意事项gitlab会监视仓库内每个分支上的.gitlab-ci.yml文件，在仓库更新的时候触发构建动作。一个仓库内可以有多个.gitlab-ci.yml文件，每个文件都可以成为一个Pipeline,GitLab通过对job的解析，job指定的分支与当前分支对应，并且根据tags等信息匹配到runner时，构成一条可用的Pipeline。可用的Pipeline可以在gitlab上直接查看。 job通过stage标明自己所属的阶段，通过only和except来选定可以触发执行的分支。通过tags来指定执行命令的具体runner，当没有tags的时候，所有允许执行没有标签的作业的runner来执行命令。建议大家在配置的时候，建立好tags的对应关系。 文件格式配置文件中除了保留字及其含义，搬运自官方文档: Keyword Required Description image no Use docker image, covered in Use Docker services no Use docker services, covered in Use Docker stages no Define build stages types no Alias for stages (deprecated) before_script no Define commands that run before each job’s script after_script no Define commands that run after each job’s script variables no Define build variables cache no Define list of files that should be cached between subsequent runs 除此之外的key，都被定义为job，在我给出的配置文件中，install、test、deploy_dev、deploy_test均为job。job定义的属性为: Keyword Required Description script yes Defines a shell script which is executed by Runner image no Use docker image, covered in Using Docker Images services no Use docker services, covered in Using Docker Images stage no Defines a job stage (default: test) type no Alias for stage variables no Define job variables on a job level only no Defines a list of git refs for which job is created except no Defines a list of git refs for which job is not created tags no Defines a list of tags which are used to select Runner allow_failure no Allow job to fail. Failed job doesn’t contribute to commit status when no Define when to run job. Can be on_success, on_failure, always or manual dependencies no Define other jobs that a job depends on so that you can pass artifacts between them artifacts no Define list of job artifacts cache no Define list of files that should be cached between subsequent runs before_script no Override a set of commands that are executed before job after_script no Override a set of commands that are executed after job environment no Defines a name of environment to which deployment is done by this job coverage no Define code coverage settings for a given job retry no Define how many times a job can be auto-retried in case of a failure 更多参考 官方说明 结果查看配置结束以后，就可以在GitLab的Pipeline和Jobs两个地方看到执行情况了，在Jobs的位置可以看到每个步骤在服务器上的执行情况。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>CI</tag>
      </tags>
  </entry>
</search>
